\graphicspath{{pki-key-sharing}}
\section{Gestione e distribuzione delle chiavi crittografiche}
\paragraph{Gestione delle chiavi crittografiche}L'uso sicuro degli algoritmi di chiave crittografica dipende dalla protezione delle chiavi crittografiche; la loro gestione è il processo di amministrazione o gestione delle chiavi crittografiche per un sistema crittografico: comporta la generazione, la creazione, la protezione, l'archiviazione, lo scambio, la sostituzione e l'utilizzo delle chiavi e consente restrizioni selettive per determinate chiavi. Oltre alla restrizione di accesso, la gestione delle chiavi implica anche il monitoraggio e la registrazione dell'accesso, dell'uso e del contesto di ciascuna chiave. Un sistema di gestione delle chiavi includerà anche server di chiavi, procedure per gli utenti e protocolli. La sicurezza del sistema crittografico dipende dalla gestione efficace delle chiavi. 

\paragraph{Tecnica di distribuzione delle chiavi}Affinché la crittografia simmetrica funzioni, le due parti coinvolte in uno scambio devono condividere la stessa chiave che deve essere protetta dall'accesso di terzi. Inoltre, cambi frequenti della chiave sono solitamente auspicabili per limitare la quantità di dati compromessi se un attaccante riesce a scoprire la chiave. Pertanto, la forza di qualsiasi sistema crittografico dipende dalla tecnica di distribuzione delle chiavi, un termine che si riferisce ai mezzi per consegnare una chiave a due parti che desiderano scambiare dati, senza consentire ad altri di vedere la chiave. 
\paragraph{Distribuzione della chiave simmetrica}Per due parti A e B, la distribuzione della chiave può essere realizzata in diversi modi:
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{distribuzione-chiavi-tra-due-entità}
	\caption{opzioni per la distribuzione delle chiavi.}
		\label{fig:distribuzione-chiavi}
\end{figure}
\begin{enumerate}[(a)]
	\item A può selezionare una chiave e consegnarla fisicamente a B;
	\item una terza parte può selezionare la chiave  e consegnarla fisicamente sia ad A che a B;
	\item se A e B hanno precedentemente e recentemente utilizzato una chiave,  una delle parti può trasmettere la nuova chiave all'altra, cifrata utilizzando la vecchia chiave;
	\item se A e B hanno ciascuno una connessione crittografata con una terza parte C, C può consegnare una chiave sui collegamenti crittografati a A e B.
\end{enumerate}
Le opzioni 1 e 2 richiedono la consegna manuale di una chiave. Per la crittografia dei collegamenti, questo è un requisito ragionevole, poiché ogni dispositivo di crittografia dei collegamenti scambierà dati solo con il suo partner all'altro capo del collegamento. Tuttavia, per la crittografia end-to-end su una rete, la consegna manuale è scomoda. In un sistema distribuito, qualsiasi utente  o server può dover partecipare a scambi con molti altri utenti e server nel tempo. Pertanto, ogni endpoint ha bisogno di un certo numero di chiavi fornite dinamicamente. Il problema è particolarmente difficile in un sistema distribuito su una vasta area.

La scala del problema dipende dal numero di coppie comunicanti che devono essere supportate. Se la crittografia end-to-end viene eseguita a livello di rete o IP, allora è necessaria una chiave per ogni coppia di host sulla rete che desidera comunicare. Pertanto, se ci sono $n$ host, il numero di chiavi richieste è: $$\frac{n(n-1)}{2}$$ Se la crittografia viene eseguita a livello di applicazione, allora è necessaria una chiave per ogni coppia di utenti o processi che richiedono comunicazione. Pertanto, una rete può avere centinaia di host ma migliaia di utenti e processi. Una rete che utilizza la crittografia a livello di nodo con 1000 nodi potrebbe concepibilmente dover distribuire fino a mezzo milione di chiavi. Se quella stessa rete supporta 10.000 applicazioni, allora potrebbero essere necessarie fino a 50 milioni di chiavi per la crittografia a livello di applicazione.

L'opzione 3 è una possibilità sia per la crittografia dei collegamenti che per la crittografia end-to-end, ma se un attaccante riesce mai a ottenere l'accesso a una chiave, tutte le chiavi saranno rilevate. Inoltre, la distribuzione iniziale di potenzialmente milioni di chiavi deve ancora essere effettuata. 

Per la crittografia end-to-end, una qualche variazione dell'opzione 4 è stata ampiamente adottata. In questo schema, un centro di distribuzione delle chiavi è responsabile della distribuzione delle chiavi a coppie di utenti (host, processi, applicazioni) secondo necessità. Ogni utente deve condividere una chiave unica con il centro di distribuzione delle chiavi per scopi di distribuzione delle chiavi.

La \cref{fig:distribuzione-chiavi} illustra due diverse opzioni, ciascuna con due variazioni per la distribuzione delle chiavi. I numeri lungo le linee rappresentano i passaggi dello scambio. In questi esempi, esiste una connessione tra le entità A e B, che desiderano scambiare informazioni utilizzando tecniche crittografiche. A questo scopo, necessitano di una chiave di sessione temporanea che durerà per la durata di una connessione logica, come una connessione TCP. A e B condividono ciascuno una chiave master di lunga durata con una terza parte coinvolta nella fornitura della chiave di sessione. La chiave di sessione è etichettata come $\ks$ e le chiavi master tra le entità A e B e la terza parte sono etichettate come $K_{ma}$ e $K_mb$ rispettivamente. Un centro di traduzione chiavi (KTC) trasferisce chiavi simmetriche per future comunicazioni tra due entità, almeno una delle quali ha la capacità di generare o acquisire chiavi simmetriche autonomamente. L'entità A genera o acquisisce una chiave simmetrica da utilizzare come chiave di sessione per la comunicazione con B. A cripta la chiave utilizzando la chiave master che condivide con il KTC e invia la chiave criptata al KTC. Il KTC decripta la chiave di sessione, la cripta nuovamente con la chiave master che condivide con B e invia quella chiave di sessione criptata nuovamente ad A affinché A la inoltri a B, oppure la invia direttamente a B.

\paragraph{KDC (Key Distribution Center)}Un centro di distribuzione chiavi (KDC) genera e distribuisce chiavi di sessione. L'entità A invia una richiesta al KDC per una chiave simmetrica da utilizzare come chiave di sessione per la comunicazione con B. Il KDC genera una chiave di sessione simmetrica, quindi la cripta con la chiave master che condivide con B e la invia a B. In alternativa, invia entrambi i valori di chiave criptati ad A, e A inoltra la chiave di sessione criptata con la chiave master condivisa dal KDC e B a B.

Vi sono un certo numero di dettagli omessi, ad esempio, le parti che scambiano chiavi devono autenticarsi reciprocamente. I timestamp sono spesso utilizzati per limitare il tempo in cui può avvenire uno scambio di chiavi e/o la durata di vita di una chiave scambiata.

\paragraph{Gerarchia delle chiavi}
\begin{figure}
	\centering
	\includegraphics[width=.5\linewidth]{key-hierarchy}
\end{figure}
Un requisito comune in una varietà di protocolli come IEEE 802.11 e IPsec è la crittografia di una chiave simmetrica in modo che possa essere distribuita a due parti per future comunicazioni. Spesso, un protocollo richiede una gerarchia di chiavi con chiavi più basse nella gerarchia utilizzate più frequentemente e cambiate più spesso per contrastare gli attacchi. Una chiave di livello superiore, che viene utilizzata raramente, e quindi è più resistente alla crittoanalisi, viene utilizzata per crittografare una chiave di livello inferiore appena creata in modo che possa essere scambiata tra le parti che condividono la chiave di livello superiore. Il termine chiave effimera si riferisce a una chiave che viene utilizzata solo una volta o al massimo ha una vita molto breve.


\subsection{Distribuzione delle chiavi simmetriche} 
\paragraph{Utilizzo della crittografia asimmetrica} A causa dell'inefficienza dei sistemi crittografici a chiave pubblica, essi sono quasi mai utilizzati per la crittografia diretta di blocchi di grandi dimensioni, ma sono limitati a blocchi relativamente piccoli. Uno degli usi più importanti di un sistema crittografico a chiave pubblica è quello di crittografare chiavi segrete per la distribuzione. 

\paragraph{Distribuzione semplice delle chiavi segrete}
\begin{figure}[thbp]
	\centering
	\includegraphics[width=\linewidth]{simple-use-pbkey-encr-session}
\end{figure}

Uno schema estremamente semplice è stato proposto da Merkle. Se A desidera comunicare con B, viene impegata la seguente procedura:
\begin{enumerate}
	\item A genera una coppia di chiavi pubblica/privata $\{\pu{a},\pr{a}\}$ e trasmette a B un messaggio contenente $\pu{a}$ e un indentificatore di A, $\id{a}$;
	\item B genera una chiave segreta $\ks$, e la trasmette a A, che è criptata con la chiave pubblica di A;
	\item A calcola $\dr{\pr{a}}{\er{\pu{a}}{\ks}}$ per recuperare la chiave segreta. Pouché solo A può decriptare il messaggio, solo A e B conosceranno l'identità di $\ks$;
	\item  A scarta $\pu{A}$ e $\pr{A}$ e B scarta $\pu{B}$.
\end{enumerate}
A e B possono ora comunicare in modo sicuro utilizzando la crittografia convenzionale e la chiave di sessione $\ks$. Al termine dello scambio, sia A che B scartano $\ks$. Nonostante la sua semplicità, questo è un protocollo attraente. Non esistono chiavi prima dell'inizio della comunicazione e nessuna esiste dopo il completamento della comunicazione . Pertanto il rischio di compromissione delle chiavi è minimo. Allo stesso tempo, la comunicazione è sicura da intercettazioni. Ma il protocollo risulta essere insicuro contro un avversario che può intercettare i messaggi e può sia inoltrare il messaggio intercettato, sia sostituirlo con un altro messaggio. Tale attacco è noto come attacco \textbf{man-in-the-middle}\footnote{Attacco informatico in cui qualcuno segretamente ritrasmette o altera la comunicazione tra due parti che credono di comunicare direttamente tra di loro.}. Se un avversario D ha il controllo del canale di comunicazione intermedio, allora D può compromettere la comunicazione senza essere rivelato:
\begin{enumerate}
	\item A genera una coppia di chiavi pubblica/privata $\{\pr{a},\pr{b}\}$ e trasmette un messaggio destinato a B contenente $\pu{a}$ e un identificatore di A, $\id{a}$;
	\item D intercetta il messaggio, crea la propria coppia di chiavi pubblica/privata $\{\pu{d},\pr{d}\}$ e trasmette $\pu{d}||\id{a}$ a B;
	\item B genera una chiave segreta $\ks$,e trasmette $\er{\pu{d}}{\ks}$;
	\item D intercetta il messaggio e appende $\ks$ calcolando $\dr{\pr{d}}{\er{\pu{d}}{\ks}}$;
	\item D trasmette $\er{\pu{A}}{\ks}$ ad A.
\end{enumerate}
Il risultato è che sia A che B conoscono $\ks$ e non sono a conoscenza del fatto che $\ks$ è stato rivelato anche a $D$. A e B possono ora scambiarsi messaggi utilizzando $\ks$. D non interferisce più attivamente con il canale di comunicazione, ma semplicemente ascolta. Conoscendo $\ks$, D può decriptare tutti i messaggi, e sia A che B non sono a conoscenza del problema. Pertanto, questo semplice protocollo è utile solo in un ambiente in cui l'unica minaccia è l'intercettazione.

\paragraph{Distribuzione della chiave segreta con riservatezza e autenticazione} 
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{needam-schroeder-pkdist}
\end{figure}
\begin{enumerate}
	\item A utilizza la chiave pubblica di B per crittografare un messaggio a B contenente un identificatore di A $\id{a}$ e un nonce $\n{1}$ che viene utilizzato per identificare univocamente questa transazione;
	\item B invia un messaggio ad A crittografato con $\pu{A}$ e contenente il nonce di A $\n{1}$ così come un nuovo nonce generato da B $\n{2}$. Poiché solo B potrebbe aver decriptato il messaggio (1), la presenza di $\n{1}$ nel messaggio (2) assicura ad A che il corrispondente è B;
	\item A restituisce $\n{2}$, crittografato utilizzando la chiave pubblica di B, per assicurare a B che il suo corrispondente è A;
	\item A seleziona una chiave segreta $\ks$ e invia $M=\er{\pu{b}}{\er{\pr{a}}{\ks}}$ a B. La crittografia di questo messaggio con la chiave pubblica di B assicura che solo B possa leggerlo; la crittografia con la chiave privata di A assicura che solo A possa averlo inviato (firma di A);
	\item B calcola $\dr{\pu{a}}{\dr{\pr{b}}{M}}$ per recuperare la chiave segreta.
\end{enumerate}

Il risultato è che questo schema garantisce sia la riservatezza che l'autenticazione nello scambio di una chiave segreta.

\paragraph{Distribuzione delle chiavi pubbliche}
\begin{enumerate}
	\bitem{Annuncio pubblico delle chiavi pubbliche}
	\begin{figure}[thbp]
		\centering
		\includegraphics[width=.7\linewidth]{uncontrolled-pkdistr}
	\end{figure}
	 Se esiste un algoritmo di chiave pubblica ampiamente accettato, come RSA, qualsiasi partecipante può inviare la propria chiave pubblica a qualsiasi altro partecipante o trasmettere la chiave alla comunità in generale. Sebbene questo approccio sia conveniente, presenta una grande debolezza. Chiunque può falsificare un tale annuncio pubblico. Cioè, un utente potrebbe fingersi l'utente A e inviare una chiave pubblica a un altro partecipante o trasmettere tale chiave pubblica. Fino a quando l'utente A non scopre la falsificazione e avvisa gli altri partecipanti, il falsario è in grado di leggere tutti i messaggi crittografati destinati ad A e può utilizzare le chiavi falsificate per l'autenticazione. 
	 \bitem{Directory pubblicamente disponibile} un maggiore grado di sicurezza può essere raggiunto mantenendo una directory dinamica di chiavo pubbliche, pubblicamente disponibile. La manutenzione e la distribuzione della directory pubblica dovrebbe essere responsabilità di un'entità o organizzazione fidata. Tale schema includerebbe i seguenti elementi:
	 \begin{enumerate}
	 	\item l'autorità mantiene una directory con un'entrata {nome,  chiave pubblica} per ciascun partecipante;
	 	\item  ogni partecipante registra una chiave pubblica presso l'autorità della directory. La registrazione dovrebbe avvenire di persona o tramite qualche forma di comunicazione sicura e autenticata;
	 	\item un partecipante può sostituire la chiave esistente con una nuova in qualsiasi momento, sia per il desiderio di sostituire una chiave pubblica che è già stata utilizzata per una grande quantità di dati, sia perché la chiave privata corrispondente è stata compromessa in qualche modo;
	 	\item i partecipanti potrebbero anche accedere alla directory elettronicamente. A tal fine, è obbligatoria una comunicazione sicura e autenticata dall'autorità al partecipante. 
	 \end{enumerate}
 	\bitem{Autorità delle chiavi pubbliche}una sicurezza più forte per la distribuzione delle chiavi pubbliche può essere raggiunta fornendo un controllo più rigoroso sulla distribuzione delle chiavi pubbliche dalla directory. 
 	\begin{figure}
 		\centering
 		\includegraphics[width=.7\linewidth]{pki-distr-scenario}
 		\caption{autorità delle chiavi pubbliche.}
 		\label{fig:autorità-chiavi-pubbliche}
 	\end{figure}
 	Come prima lo scenario assume che un'autorità centrale mantenga una directory dinamica delle chiavi pubbliche di tutti i partecipanti. Inoltre, ogni partecipante conosce in modo affidabile una chiave pubblica per l'autorità, con solo l'autorità che conosce la corrispondente chiave privata. Si verificano i seguenti passaggi:
 	\begin{enumerate}[label=\arabic*.]
 		\item A invia un messaggio con timestamp all'autorità delle chiavi pubbliche contenente una richiesta per la chiave pubblica attuale di B. 
 		\item L'autorità risponde con un messaggio che è crittografato utilizzando la chiave privata dell'autorità $\pr{auth}$.  Pertanto, A è in grado di decriptare il messaggio utilizzando la chiave pubblica dell'autorità. Di conseguenza, A è assicurato che il messaggio provenga dall'autorità. Il messaggio include:
 		\begin{itemize}
 			\item la chiave pubblica di B, $\pu{b}$ che A può utilizzare per crittografare i messaggi destinati a B;
 			\item la richiesta originale utilizzata per consentire ad A di abbinare questa risposta con la corrispondente richiesta precedente e per verificare che la richiesta originale non sia stata alterata prima della ricezione da parte dell'autorità;
 			\item il timestamp originale fornito affinché A possa determinare che questo non è un messaggio vecchio dell'autorità contenente una chiave diversa dalla chiave pubblica attuale di B.
 		\end{itemize}
 		\item A memorizza la chiave pubblica di B e la utilizza anche per crittografare un messaggio a B contenente un identificatore di A $\id{a}$ e un nonce $\n{1}$, che viene utilizzato per identificare univocamente questa transazione;
 		\item[\label=4 e 5.] B recupera la chiave pubblica di A dall'autorità nello stesso modo in cui A ha recuperato la chiave pubblica di B. A questo punto, le chiavi pubbliche sono state consegnate in modo sicuro ad A e B, e possono iniziare il loro scambio protetto. Tuttavia, sono desiderabili due ulteriori passaggi;
 		\setcounter{enumii}{5}
 		\item B invia un messaggio ad A crittografato con $\pu{A}$ e contenente il nonce di A $\n{1}$ così come un nuovo nonce generato da B $\n{2}$. Poiché solo B potrebbe aver decriptato il messaggio (3), la presenza di $\n{1}$ nel messaggio (6) assicura ad A che il corrispondente è B;
 		\item A restituisce $\n{2}$, crittografato utilizzando la chiave pubblica di B, per assicurare a B che il suo corrispondente è A.
 	\end{enumerate}
 	Pertanto, sono richiesti un totale di sette messaggi. Tuttavia, i primi cinque messaggi devono essere utilizzati solo raramente, poiché sia A che B possono salvare la chiave pubblica dell'altro per un uso futuro -- una tecnica nota come caching. Periodicamente, un utente dovrebbe richiedere copie fresche delle chiavi pubbliche dei suoi corrispondenti per garantire la loro attualità. 
\end{enumerate}
\subsection{Certificati di chiave pubblica}
Lo scenario nella \cref{fig:autorità-chiavi-pubbliche} presenta alcuni svantaggi. L'autorità delle chiavi pubbliche potrebbe rappresentare un collo di bottiglia nel sistema, poiché un utente deve fare riferimento all'autorità per ottenere la chiave pubblica di ogni altro utente che desidera contattare. Come prima, la directory di nomi e chiavi pubbliche mantenuta dall'autorità è vulnerabile a manomissioni. 

Un approccio alternativo, suggerito per la prima volta da Kohnfelder, è quello di utilizzare certificati che possono essere usati dai partecipanti per scambiare chiavi senza contattare un'autorità delle chiavi pubbliche, in un modo che è affidabile come se le chiavi fossero ottenute direttamente da un'autorità delle chiavi pubbliche. In sostanza, un certificato consiste in una chiave pubblica, un identificatore del proprietario della chiave e l'intero blocco firmato da una terza parte fidata. Tipicamente, la terza parte è un'autorità di certificazione, come un'agenzia governativa o un'istituzione finanziaria, che è fidata dalla comunità degli utenti. Un agente può presentare la propria chiave pubblica all'autorità in modo sicuro e ottenere un certificato. L'utente può ottenere il certificato e verificare che sia valido tramite la firma fidata allegata. Un partecipante può anche trasmettere le proprie informazioni sulla chiave a un altro trasmettendo il proprio certificato. Altri partecipanti possono verificare che il certificato sia stato creato dall'autorità. 

Possiamo porre i seguenti requisiti su questo schema:

\begin{enumerate}
	\item qualsiasi partecipante può leggere un certificato per determinare il nome e la chiave pubblica del proprietario del certificato;
	\item qualsiasi partecipante può verificare che il certificato provenga dall'autorità di certificazione e non sia contraffatto;
	\item solo l'autorità di certificazione può creare e aggiornare i certificati;
	\item qualsiasi partecipante può verificare la validità temporale del certificato.
\end{enumerate}
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{pkexchange-certificates}
	\caption{schema di certificato.}
	\label{fig:schema-certificato}
\end{figure}
Nello schema di certificato (\cref{fig:schema-certificato}), ogni partecipante fa richiesta all'autorità di certificazione, fornendo una chiave pubblica e richiedendo un certificato. La richiesta deve avvenire di persona o tramite qualche forma di comunicazione sicura  e autenticata. Per il partecipante A, l'autorità fornisce un certificato della forma:
$$C_A=\er{\pr{auth}}{[T||\id{a}||\pu{a}]}$$
dove $\pr{auth}$ è la chiave privata utilizzata dall'autorità e $T$ è un timestamp. A può quindi trasmettere questo certificato a qualsiasi altro partecipante, che legge e verifica il certificato come segue:
$$\dr{\pu{auth}}{C_A}=\dr{\pu{auth}}{\er{\pr{auth}}{[T||\id{a}||\pu{a}]}}=(T||\id{a}||\pu{a})$$
Il destinatario utilizza la chiave pubblica dell'autorità, $\pu{auth}$ per decifrare il certificato. Poiché il certificato è leggibile solo utilizzando la chiave pubblica dell'autorità, questo verifica che il certificato provenga dall'autorità di certificazione. Gli elementi $\id{a}$ e $\pu{a}$ forniscono al destinatario il nome A e la chiave pubblica del titolare del certificato. Il timestamp $T$ convalida l'attualità del certificato. Il timestamp contrasta il seguente scenario: la chiave privata di A viene appresa da un avversario. A genera una nuova coppia di chiavi private/pubbliche e fa richiesta all'autorità di certificazione per un nuovo certificato. Nel frattempo, l'avversario riproduce il vecchio certificato a B. Se B crittografa i messaggi utilizzando la vecchia chiave pubblica compromessa, l'avversario può leggere quei messaggi. 

In questo contesto, la compromissione di una chiave privata è paragonabile alla perdita di una carta di credito. Il proprietario annulla il numero della carta di credito ma è a rischio fino a quanto tutti i possibili comunicanti non sono a conoscenza del fatto che la vecchia carta di credito è obsoleta. Pertanto, il timestamp funge da data di scadenza. Se un certificato è sufficientemente vecchio, si presume che sia scaduto.

Uno schema è diventato universalmente accettato per la formattazione dei certificati di chiave pubblica: lo standard X.509. I certificati X.509 sono utilizzati nella maggior parte delle applicazioni di sicurezza di rete, inclusi la sicurezza IP, la sicurezza del livello di trasporto (TLS) e S/MIME.

\subsubsection{Certificati X.509}
La raccomandazione ITU-T X.509 fa parte della serie di raccomandazioni X.500 che definiscono un servizio di directory. La \textbf{directory} è, in effetti, un server o un insieme distribuito di server che gestisce un database di informazioni sugli utenti. Le informazioni includono una mappatura dal nome utente all'indirizzo di rete, oltre ad altri attributi e informazioni sugli utenti.

X.509 definisce un framework per la fornitura di servizi di autenticazione da parte della directory X.500 ai suoi utenti. La directory può fungere da repository di certificati a chiave pubblica. Ogni certificato contiene la chiave pubblica di un utente ed è firmato con la chiave privata di un'autorità di certificazione (CA) fidata. Inoltre, X.509 definisce protocolli di autenticazione alternativi basati sull'uso di certificati a chiave pubblica.
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{x509-use}
	\caption{funzionamento di X.509.}
	\label{fig:x509-fn}
\end{figure}
X.509 è uno standard importante perché la struttura dei certificati e i protocolli di autenticazione definiti in X.509 sono utilizzati in una varietà di contesti. Ad esempio, il formato del certificato X.509 è utilizzato in S/MIME, IP Security e SSL/TLS.

X.509 si basa sull'uso della crittografia a chiave pubblica e delle firme digitali. Lo standard non impone l'uso di uno specifico algoritmo di firma digitale né di una specifica funzione hash. La \cref{fig:x509-fn} illustra lo schema generale X.509 per la generazione di un certificato a chiave pubblica. Il certificato per la chiave pubblica di Bob include informazioni di identificazione univoche per Bob, la chiave pubblica di Bob e informazioni di identificazione sulla CA, oltre ad altre informazioni come spiegato di seguito. Queste informazioni vengono quindi firmate calcolando un valore hash delle informazioni e generando una firma digitale utilizzando il valore hash e la chiave privata della CA. Bob può quindi trasmettere questo certificato ad altri utenti o allegare il certificato a qualsiasi documento o blocco di dati che firma. Chiunque abbia bisogno di utilizzare la chiave pubblica di Bob può essere certo che la chiave pubblica contenuta nel certificato di Bob sia valida perché il certificato è firmato dalla CA fidata.

\paragraph{Elementi di un certificato X.509}

\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{formato-x509}
\end{figure}
\begin{itemize}
	\bitem{Versione}differenzia tra le versioni successive del formato del certificato; il valore predefinito è la versione 1. Se l'identificatore univoco dell'emettente o l'identificatore univoco del soggetto sono presenti, il valore deve essere la versione 2. Se sono presenti una o più estensioni, la versione deve essere la versione 3. Sebbene a specifica X.509 sia attualmente alla versione 7, non sono state apportate modifiche ai campi che compongono il certificato dalla versione 3.
	\bitem{Numero di serie}un valore intero unico all'interno della CA emittente che è inequivocabilmente associato a questo certificato.
	\bitem{Identificatore dell'algoritmo di firma}l'algoritmo utilizzato per firmare il certificato insieme a eventuali parametri associati. Poiché queste informazioni sono ripetute nel campo della firma alla fine del certificato, questo campo ha poca, se non alcuna, utilità.
	\bitem{Nome dell'emittente}nome X.500 della CA che ha creato e firmato questo certificato.
	\bitem{Periodo di validità}consiste in due date: la prima e l'ultima in cui il certificato è valido.
	\bitem{Periodo di validità}consiste in due date: la prima e l'ultima in cui il certificato è valido.
	\bitem{Nome del soggetto}nome dell'utente a cui si riferisce questo certificato. Cioè, questo certificato certifica la chiave pubblica del soggetto che detiene la corrispondente chiave privata.
	\bitem{Informazioni sulla chiave pubblica del soggetto}la chiave pubblica del soggetto, più un identificatore dell'algoritmo per il quale questa chiave deve essere utilizzata, insieme a eventuali parametri associati.
	\bitem{Identificatore univoco dell'emittente}n campo di stringa di bit opzionale utilizzato per identificare univocamente la CA emittente nel caso in cui il nome X.500 sia stato riutilizzato per entità diverse.
	\bitem{Identificatore univoco del soggetto}un campo di stringa di bit opzionale utilizzato per identificare univocamente il soggetto nel caso in cui il nome X.500 sia stato riutilizzato per entità diverse.
	\bitem{Estensioni} un insieme di uno o più campi di estensione. Le estensioni sono state aggiunte nella versione 3.
	\bitem{Firma}copre tutti gli altri campi del certificato. Un componente di questo campo è la firma digitale applicata agli altri campi del certificato. Questo campo include l'identificatore dell'algoritmo di firma. I campi identificatori univoci sono stati aggiunti nella versione 2 per gestire il possibile riutilizzo dei nomi dei soggetti e/o degli emittenti nel tempo. Questi campi sono raramente utilizzati.
\end{itemize}

L'autorità di certificazione firma il certificato con la sua chiave privata. Se la corrispondente chiave pubblica è nota a un utente, allora quell'utente può verificare che un certificato firmato dalla CA sia valido.
\paragraph{Ottenere un certificato}I certificati utente generati da una CA hanno le seguenti caratteristiche:
\begin{itemize}
	\item qualsiasi utente con accesso alla chiave pubblica della CA può verificare la chiave pubblica dell'utente che è stata certificata;
	\item nessuna parte, tranne l'autorità di certificazione, piò modificare il certificato senza che ciò venga rilevato.
\end{itemize}
Poiché i certificati sono inalterabili, possono essere collocati in una directory senza la necessità che la directory faccia sforzi speciali per proteggerli. Inoltre, un utente può trasmettere il proprio certificato direttamente ad altri utenti. Una volta che B è in possesso del certificato di A, B ha fiducia che i messaggi che crittografa con la chiave pubblica di A saranno sicuri da intercettazioni e che i messaggi firmati con la chiave privata di A sono inalterabili.
\subsubsection{Modelli di fiducia}Diversi modelli di fiducia determinano come gli utenti stabiliranno la validità dei certificati.
\paragraph{Fiducia diretta}Se tutti gli utenti si abbonano alla stessa CA, allora c'è una fiducia comune in quella CA. Tutti i certificati utente possono essere collocati nella stessa directory per l'accesso da parte di tutti gli utenti. Inoltre, la trasmissione dei certificati da utente a utente (come in PGP) è possibile.
\paragraph{Fiducia gerarchica e albero di fiducia}Per una grande comunità di utenti, è più pratico avere un numero di CA, ciascuna delle quali fornisce in modo sicuro la propria chiave pubblica a una frazione degli utenti. La fiducia si estende da un certo numero di certificati radice. Questi certificati possono certificare certificati stessi, oppure possono certificare certificati che certificano ancora altri certificati lungo una certa catena. La validità del certificato foglia è verificata tracciando all'indietro dal suo certificatore, ad altri certificatori, fino a quando non si trova un certificato radice direttamente fidato.
\paragraph{Cross-certificazione}Supponiamo che A e B abbiano ottenuto certificati dalle CA $X_1$ e $X_2$ rispettivamente. Se A non conosce in modo sicuro la chiave pubblica di $X_2$, allora A non può convalidare il certificato di B. Se le CA hanno scambiato le proprie chiavi pubbliche, allora A può ottenere la chiave pubblica di B tramite una catena di certificati (\textbf{cross-certificazione}).

 A ottiene dalla directory, il certificato $X_2$ firmato da $X_1$ e può così ottenere la chiave pubblica di $X_2$ (e verificarla tramite la firma di $X_1$ sul certificato). A poi torna alla directory e ottiene il certificato di B firmato da $X_2$, che A può ora verificare con la copia fidata della chiave pubblica di $X_2$.

In X.509 questa catena di certificati è espressa come:
$$X_1\crt{X_2}X_2\crt{B}$$
B ottiene la chiave pubblica di A con la chiave inversa:
$$X_2\crt{X_1}X_1\crt{A}$$
Una catena con $n$ elementi è:$$X_1\crt{X_2}X_2\crt{X_3}\dots X_n\crt{B}$$
dove ogni coppia $(X_i,X_{i+1})$ di CA nella catena ha creato certificato l'uno per l'altro (memorizzati nella directory).
\paragraph{Gerarchia X.509}
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{x509-tree}
	\caption{gerarchia X.509.}
	\label{fig:gerarchia-x509}
\end{figure}
Cerchi connessi indicano la relazione gerarchica tra le CA. I rettangoli indicano i certificati mantenuti nella directory per ciascun ingresso della CA. 
\begin{itemize}
	\bitem{Certificati in avanti} certificati di X generati da altre CA.
	\bitem{Certificati inversi}certificati di altre CA generati da X.
\end{itemize}
\paragraph{Percorsi di connessione}Facendo riferimento alla \cref{fig:gerarchia-x509}
\begin{itemize}
	\item Percorso $A\to B$: $X\crt{W}W\crt{V}V\crt{Y}Y\crt{Z}Z\crt{B}$
	\item Percorso $B\to A$: $Z\crt{Y}Y\crt{V}V\crt{W}W\crt{X}X\crt{A}$
\end{itemize}
\paragraph{Revoca dei certificati}
\begin{itemize}
	\item Ogni certificato include un periodo di validità. Tipicamente, un nuovo certificato viene emesso poco prima della scadenza del vecchio.
	\item Può essere desiderabile, in alcune occasioni, revocare un certificato prima della scadenza, per uno dei seguenti motivi:
	\begin{itemize}
		\item la chiave privata dell'utente si presume compromessa;
		\item l'utente non è più certificato da questa CA;
		\item il certificato della CA si presume compromesso.
	\end{itemize}
	\item Ogni CA deve mantenere un elenco composto da tutti i certificati revocati ma non scaduti emessi da quella CA. Questi elenchi dovrebbero essere pubblicati nella directory.
\end{itemize}
\paragraph{X.509 v3}Il formato della versione 2 non trasmette tutte le informazioni che l'esperienza recente di progettazione e implementazione ha dimostrato essere necessarie. Invece di continuare ad aggiungere campi a un formato fisso, gli sviluppatori di standard hanno ritenuto necessario un approccio più flessibile. La versione 3 include un numero di estensioni opzionali. Le estensioni del certificato rientrano in tre categorie principali:
\begin{itemize}
	\item informazioni su chiavi e politiche (trasmettono informazioni aggiuntive sulle chiavi del soggetto e dell'emittente, oltre a indicatori della politica del certificato);
	\item attributi del soggetto e dell'emittente (supportano nomi alternativi, in formati alternativi, per un soggetto del certificato o un emittente del certificato);
	\item vincoli sul percorso di certificazione (consentono di includere specifiche di vincolo nei certificati emessi per le CA da altre CA).
\end{itemize}
Ogni estensione consiste di un identificatore dell'estensione, un suo indicatore di criticità e un suo valore.
\paragraph{Interazione dei vari componenti}
\begin{figure}[thbp]
	\centering
	\includegraphics[width=.7\linewidth]{pki-scenario}
\end{figure}
 Considera una parte affidabile, Alice, che ha bisogno di utilizzare la chiave pubblica di Bob. Alice deve prima ottenere in modo affidabile e sicuro una copia della chiave pubblica della CA. Questo può essere fatto in diversi modi e dipende dall'architettura PKI particolare e dalla politica aziendale.

Se Alice desidera inviare dati crittografati a Bob, controlla con il Repository per determinare se il certificato di Bob è stato revocato e, se non lo è, ottiene una copia del certificato di Bob. Alice può quindi utilizzare la chiave pubblica di Bob per crittografare i dati inviati a Bob. Bob può anche inviare un documento ad Alice firmato con la chiave privata di Bob. Bob può includere il suo certificato con il documento o presumere che Alice abbia già o possa ottenere il certificato. In entrambi i casi, Alice utilizza prima la chiave pubblica della CA per verificare che il certificato sia valido, quindi utilizza la chiave pubblica di Bob (ottenuta dal certificato) per convalidare la firma di Bob.

Piuttosto che una singola CA, un'azienda potrebbe dover fare affidamento su più CA e più repository. Le CA possono essere organizzate in modo gerarchico, con una CA radice che è ampiamente fidata e firma il certificato della chiave pubblica delle CA subordinate. Molti certificati radice sono incorporati nei browser Web, quindi hanno una fiducia integrata in quelle CA. I server Web, i client di posta elettronica, gli smartphone e molti altri tipi di hardware e software supportano anche la PKI e contengono certificati radice fidati delle principali CA.
\subsection{Web of trust e PGP}
PGP utilizza un'infrastruttura di gestione delle chiavi basata su certificati per le chiavi pubbliche degli utenti. I certificati PGP (e la gestione delle chiavi) differiscono dai certificati X.509 in diversi modi importanti, ad esempio:
\begin{itemize}
	\item una chiave PGP può avere più firme (anche ``auto firma'');
	\item ogni utente crea e firma certificati per le persone che conosce (pertanto, non è necessaria un'infrastruttura centrale);
	\item una nozione di ``fiducia'' è incorporata in ogni firma, e le firme per una singola chiave possono avere diversi livelli di fiducia (e gli utenti di un certificato agiscono in base al livello di fiducia);
	\item in un ambiente PGP, qualsiasi utente può agire come un'autorità di certificazione:
	\begin{itemize}
		\item le firme digitali vengono usate come forma di introduzione: quando un utente firma la chiave di un altro, diventa introduttore di quella chiave;
		\item man mano che questo processo continua, si stabilisce una rete di fiducia;
	\end{itemize}
	\item qualsiasi utente PGP può convalidare il certificato della chiave pubblica di un altro utente, ma tale certificato è valido per un altro utente solo se riconosce il validatore come un introduttore fidato.
\end{itemize}
\paragraph{Sistema di reputazione in PGP}Memorizzati nel keyring pubblico di ciascun utente ci sono indicatori che mostrano se l'utente considera una particolare chiave valida e il livello di fiducia che l'utente ripone nella chiave, in quanto ne è il proprietario, può fungere da certificatore delle chiavi di altri.
\paragraph{Esempio PGP}
Alice vuole comunicare con Bob. Ottiene il certificato della chiave pubblica PGP di Bob, ad esempio:

$$
\text{Ellen, Fred, Giselle }  \crt{\text{ Bob }} 
$$

Alice non conosce nessuno dei firmatari, quindi da un server di certificati ottiene il certificato PGP di Giselle:

$$
\text{Henry, Irene, Giselle } \crt{\text{ Giselle }} 
$$

Conosce vagamente Henry, quindi per verificare il certificato di Giselle ottiene il certificato di Henry:

$$
\text{Ellen, Henry } \crt{\text{ Henry } }
$$

Dunque abbiamo:

\begin{itemize}
	\item $\text{Ellen, Fred, Giselle } \crt{\text{ Bob } }$
	\item $\text{Henry, Irene, Giselle } \crt{\text{ Giselle } }$
	\item $\text{Ellen, Henry } \crt{\text{ Henry } }$
\end{itemize}

Alice nota che la firma di Henry è al livello di fiducia \textbf{casuale}, quindi decide di cercare conferma altrove. Ottiene il certificato di Ellen:

$$
\text{Jack, Ellen } \crt{\text{ Ellen } }
$$

Riconosce immediatamente Jack come suo cugino e, poiché ha il certificato di Jack, lo utilizza per convalidare il certificato di Ellen: nota che la sua firma è al livello di fiducia \textbf{positivo}, e quindi accetta il certificato di Ellen come valido e lo utilizza per convalidare quello di Bob.

Nota che anche Ellen ha firmato il certificato con fiducia \textbf{positiva}, quindi conclude che il certificato, e la chiave pubblica che contiene, sono \textbf{affidabili}.

Alice ha seguito due catene di firme:

\begin{itemize}
	\item $\text{Henry}  \crt{\text{ Henry } }\longrightarrow \text{ Henry} \crt{\text{ Giselle } }\longrightarrow \text{ Giselle} \crt{\text{ Bob } }$
	\item $\text{Jack}\crt{\text{ Ellen } }\longrightarrow \text{ Ellen} \crt{\text{ Bob }} $
\end{itemize}

(dove le firme non verificate sono state omesse).

I livelli di fiducia hanno influenzato il modo in cui Alice ha controllato il certificato.


\paragraph{Distinzione tra Certificati X.509 e PGP}

\begin{itemize}
	\item I certificati \textbf{X.509} includono un elemento di fiducia, ma la fiducia \textbf{non è indicata} nel certificato.
	\item I certificati \textbf{PGP} indicano il livello di fiducia, ma lo stesso livello di fiducia può avere \textbf{significati diversi} per diversi firmatari (cfr. anche risoluzione dei nomi).
\end{itemize}
\paragraph{Web of trust}La Web of trust (rete di fiducia) è un concetto fondamentale nella crittografia a chiave pubblica, in particolare utilizzato da software come PGP e GnuPG (compatibili con OpenPGP), per stabilire l'autenticità del legame tra una chiave pubblica e il suo legittimo proprietario (utente). Si tratta di un sistema deventralizzato che funge da alternativa o complemento all'affidamento esclusivo su un'autorità di certificazione (CA) centralizzata, tipica delle infrastrutture a chiave pubblica (PKI) tradizionali.
\begin{itemize}
	\bitem{Funzionamento principale}la rete di fiducia non si basa su una singola autorità, ma sul concetto di fiducia reciproca tra gli utenti:
	\begin{itemize}
		\bitem{firma del certificato}un certificato di identità OpenPGP, che contiene la chiave pubblica e le informazioni sul suo proprietario, può essere firmato elettronicamente da altri utenti.
		\bitem{Attestazione}apponendo la propria firma, un utente attesta di aver verificato (solitamente di persona, in eventi noti come \textit{key signing party}) che quella specifica chiave pubblica appartiene effettivamente a quella specifica persona.
		\bitem{Livelli di fiducia}ciascun utente configura il proprio livello di fiducia in modo indipendente, decidendo di quali chiavi firmate fidarsi. Ad esempio, un utente può decidere che un certificato è valido se è stato firmato da:
		\begin{itemize}
			\item un conoscente di cui si fida completamente;
			\item oppure, da tre conoscenti di cui si fida parzialmente.
		\end{itemize}
		
	\end{itemize}
	Questo approccio si basa sull'idea dei 6 gradi di separazione, permettendo a un utente di fidarsi indirettamente di una chiave che non ha mai incontrato, purché sia stata validata da una catena di persone fidate (i propri contatti e i loro contatti).
\end{itemize}

La differenza principale con la PKI tradizionale sta nella struttura e nella flessibilità

\begin{table}[thbp]
	\centering
	\begin{tabular}{|l|y{.3\linewidth}|y{.3\linewidth}|}
		\hline
		Caratteristica & Web of trust (PGP/GnuPG)&PKI (X.509)\\
		\hline
		\textbf{Autorità}&Decentralizzata. La fiducia è risposta negli individui. & \textbf{Centralizzata/gerarchica}. La fiducia è risposta nelle CA (autorità di certificazione).\\
		\hline
		\textbf{Validazione}& Multipla e configurabile. Le firme provengono da una rete di utenti. & Singola. Un certificato è firmato da una CA, risalendo fino a un root certificate preinstallato.\\
		\hline
		\textbf{Flessibilità} & Alta. L'utente sceglie i propri parametri di fiducia (quante firme servono e da chi). & Bassa. L'utente deve accettare implicitamente tutte le CA include nel browser o software.\\
		\hline
	\end{tabular}
\end{table}
In sintesi, la Web of trust pone il controllo e la responsabilità della validazione della chiave nelle mani dell'utente individuale, a differenza delle PKI che impongono la fiducia nelle autorità centrali.